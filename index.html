/**
 * ORION'S HUNT: LEGEND EDITION
 * Built by Claude | Powered by Gemini 2.0 Flash
 */

function doGet() {
  return HtmlService.createHtmlOutputFromFile('Index')
    .setTitle("ORION'S HUNT: LEGEND EDITION")
    .addMetaTag('viewport', 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function logGameData(data) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('GameLogs') || ss.insertSheet('GameLogs');
    
    sheet.appendRow([
      new Date(), 
      data.event, 
      data.score || 0,
      data.combo || 0,
      JSON.stringify(data.details)
    ]);
    
    if (sheet.getLastRow() === 1) {
      sheet.getRange(1, 1, 1, 5).setValues([['Timestamp', 'Event', 'Score', 'Combo', 'Details']]);
    }
  } catch(e) { 
    Logger.log("Logger Error: " + e.message); 
  }
}

function sendToGemini(payload) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
  const url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=" + apiKey;
  
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  
  try {
    const response = UrlFetchApp.fetch(url, options);
    const result = JSON.parse(response.getContentText());
    if (result.candidates && result.candidates[0]) {
      return { success: true, text: result.candidates[0].content.parts[0].text };
    }
    return { success: false, error: "Constellation link severed." };
  } catch(e) { 
    return { success: false, error: e.message }; 
  }
}

function getPlayerStats() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('GameLogs');
    if (!sheet) return { totalShots: 0, highScore: 0, totalSessions: 0 };
    
    const data = sheet.getDataRange().getValues();
    const shots = data.filter(r => r[1] === 'STRIKE').length;
    const scores = data.filter(r => r[2] > 0).map(r => r[2]);
    const highScore = scores.length ? Math.max(...scores) : 0;
    
    return { totalShots: shots, highScore: highScore, totalSessions: data.length - 1 };
  } catch(e) {
    return { totalShots: 0, highScore: 0, totalSessions: 0 };
  }
}
